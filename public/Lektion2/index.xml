<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>2. Iteration on JAdventure - Kurs zur Softwareentwicklung</title>
    <link>https://jadventure.de/Lektion2/</link>
    <description>Recent content in 2. Iteration on JAdventure - Kurs zur Softwareentwicklung</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>de-de</language><atom:link href="https://jadventure.de/Lektion2/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>2.1. Fehlende Unit Tests</title>
      <link>https://jadventure.de/Lektion2/2.1-fehlende-Unit-Tests/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jadventure.de/Lektion2/2.1-fehlende-Unit-Tests/</guid>
      <description>Unit-Test für Level.getChildren() Unit-Test, der das Löschen eines nicht vorhandenen Objects aus einem Level testet Für die Übungsaufgaben am Ende von Lektion 1 möchte ich als erstes ein paar mögliche Lösungen geben.
Unit-Test für Level.getChildren() Bei der Methode getChildren() können wir so vorgehen:
Wir legen ein Level mit einem GameObject an. Danach prüfen wir, ob getChildren() die Liste mit den GameObjects zurückliefert. /** * Tests the getObjects method. */ @Test public void testGetChildren() { Level level = new Level(&amp;#34;TestLevel&amp;#34;, 1000, 1000); GameObject obj = GameObject.</description>
    </item>
    
    <item>
      <title>2.2. Erweiterung des Modells</title>
      <link>https://jadventure.de/Lektion2/2.2-Erweiterung-des-Models/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jadventure.de/Lektion2/2.2-Erweiterung-des-Models/</guid>
      <description>Level GameObject Unit Tests Konstruktor von Level nimmt nun einen Parameter mehr Das JSON des serialisierten Level ändert sich Level und GameObject erhalten ein zusätzliches Feld &amp;ldquo;graphicResource&amp;rdquo;. Da dies einfach ein Name ist, ist dies einfach ein String.
Level package org.jadv.model.level; // ... /** * JAdventure Level */ @Getter @NoArgsConstructor @AllArgsConstructor @ToString @EqualsAndHashCode(callSuper=true) public class Level extends SavedObject implements Container { // ... /** * Height of the level. */ private int height; /** * Resource name of a graphic.</description>
    </item>
    
    <item>
      <title>2.3. Laden von Ressourcen</title>
      <link>https://jadventure.de/Lektion2/2.3-Laden-von-Ressourcen/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jadventure.de/Lektion2/2.3-Laden-von-Ressourcen/</guid>
      <description>Bereitstellung von Ressourcen Bilder Level Laden der Bilder Laden der Level Bereitstellung von Ressourcen Bilder Wir brauchen ein paar Bilder für unser Spiel, die wir als Ressourcen in unser Projekt unter src/main/resources einfügen:
Eine Grafik für einen Level-Hintergrund Mehrere Grafiken für Spielobjekte. Ich nutze dazu einfach die Grafiken, die ich bereits habe:
Das Testlevel wurde mir von DALL-E generiert DALL-E hat mir einen Drachen generiert, bei dem ich den Hintergrund nur noch transparent machen muss (Ich habe das nur grob auf die Schnelle gemacht und die Qualität ist dementsprechend schlecht in dieser ersten Version.</description>
    </item>
    
    <item>
      <title>2.4. Clean Code: Kein doppelter Code!</title>
      <link>https://jadventure.de/Lektion2/2.4-Clean-Code-Refactoring-Doppelter-Code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jadventure.de/Lektion2/2.4-Clean-Code-Refactoring-Doppelter-Code/</guid>
      <description>Nutzung eines Generics für unterschiedliche Rückgabetypen Nutzung von Parametern im Konstruktor für unterschiedliche Werte Universelle Methode Nutzung von ResourceService Alternative Lösung Eines der wichtigsten Refactorings in der Softwareentwicklung ist die Eliminierung von doppeltem Code. Dies wird um so einfacher, je mehr sich die Codestellen gleichen und je weniger Elemente von Außen genutzt werdem. Im einfachsten Fall kann man eine neue Methode erstellen, in die der doppelte Code kopiert wird. Die Elemte außerhalb des Codes werden zu Parametern und ein Ergebnis wird von der Methode zurück gegeben.</description>
    </item>
    
    <item>
      <title>2.5. Clean Code: JavaDoc</title>
      <link>https://jadventure.de/Lektion2/2.5-Clean-Code-JavaDoc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jadventure.de/Lektion2/2.5-Clean-Code-JavaDoc/</guid>
      <description>Eine Dokumentation der Funktionalität ist sehr wichtig. Clean Code soll sich selbst erklären, aber dennoch macht es Sinn, Klassen und Methoden zu dokumentieren. Dadurch entsteht dann eine Dokumentation der API, wie man dies z.B. vom Java Framework kennt.
Wir haben in 2.3 eine Klasse ResourceService geschrieben und haben diese ohne Kommentare erstellt. Das erschwert die Nutzung durch Dritte, daher sollten wir hier noch eine Dokumentation anlegen.
In dem meisten Entwicklungsumgebungen sollte es ausreichen, einen Kommentar mit /** zu starten, um dann einen Rahmen für JavaDoc zu erhalten.</description>
    </item>
    
  </channel>
</rss>
